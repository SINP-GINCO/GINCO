<?php
namespace Ign\Bundle\GincoBundle\Repository\Metadata;

use Doctrine\ORM\Query\Expr\Join;
use Doctrine\ORM\Query\ResultSetMappingBuilder;

use Ign\Bundle\GincoBundle\Entity\Generic\GenericField;
use Ign\Bundle\GincoBundle\Entity\Metadata\TableFormat;
use Ign\Bundle\GincoBundle\Entity\Metadata\Model;

/**
 * TableFieldRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class TableFieldRepository extends \Doctrine\ORM\EntityRepository {
	
	
	/**
	 * Get the fields of the table.
	 *
	 * @param
	 *        	tableFormat the name of the table format
	 *
	 * @return list of TableField
	 */
	public function findFieldsByTableFormat($tableFormat) {
		$em = $this->getEntityManager();
		$query = $em->createQuery(
			'SELECT DISTINCT dt.data as fieldName,
					dt.label as label,
					u.type as unitType, 
					tfi.isMandatory, 
					tfi.isCalculated,
                    tfi.defaultValue
			FROM IgnGincoBundle:Metadata\TableField tfi
			LEFT JOIN IgnGincoBundle:Metadata\TableFormat tfo WITH tfo.format = tfi.format
			LEFT JOIN IgnGincoBundle:Metadata\Data dt WITH tfi.data = dt.data
			LEFT JOIN IgnGincoBundle:Metadata\Unit u WITH dt.unit = u.unit
			WHERE tfi.format = :tableFormat
			ORDER BY fieldName'
		);

		$query->setParameters(array(
			'tableFormat' => $tableFormat
		));

		return $query->getResult();
	}

	/**
	 * Get the non-technical fields of the table.
	 *
	 * @param
	 *        	tableFormat the name of the table
	 *
	 * @return result of the delete query
	 */
	public function findNonTechnicalByTableFormat($tableFormat) {
		
		return $this->createQueryBuilder('t')
			->leftJoin('t.data', 'd')
			->where('t.format = :tableFormat')
			->andWhere("d.data NOT IN ('PROVIDER_ID', 'USER_LOGIN', 'SUBMISSION_ID')")
			->andWhere("d.data NOT LIKE :ogamId")
			->setParameter('tableFormat', $tableFormat)
			->setParameter('ogamId', TableFormat::PK_PREFIX . '%')
			->getQuery()
			->getResult()
		;
	}

	/**
	 * Get the fields corresponding to keys (primary and foreigns) of the table
	 *
	 * @param
	 *        	$tableFormat
	 * @return array
	 */
	public function findKeysByTableFormat($tableFormat) {
		$query = $this->_em->createQuery("SELECT t
			FROM IgnGincoBundle:Metadata\TableField t
			WHERE t.format =:tableFormat
			AND t.data LIKE :ogam_id");
		$query->setParameters(array(
			'tableFormat' => $tableFormat,
			'ogam_id' => TableFormat::PK_PREFIX . '%'
		));
		return $query->getResult();
	}
	
	/**
	 * Get all table_fields for a given model
	 *
	 * @param
	 *        	$modelId
	 * @return Array[TableField]
	 */
	public function getTableFieldsForModel(Model $model) {
		$binds = array('modelId' => $model->getId());
		//TODO : simplify select : only data, format, value are needed
		$sql = "SELECT tfi.*, d.label as label, d.unit, u.type, u.subtype, d.definition
				FROM metadata.table_field tfi
				LEFT JOIN metadata.model_tables mt ON tfi.format = mt.table_id
				LEFT JOIN metadata.data d ON tfi.data = d.data
				LEFT JOIN metadata.unit u on d.unit = u.unit
				WHERE mt.model_id = :modelId
				ORDER BY d.label";
	
		$rsm = new ResultSetMappingBuilder($this->_em);
		$rsm->addRootEntityFromClassMetadata($this->_entityName, 't');
	
		$query = $this->_em->createNativeQuery($sql, $rsm->addIndexBy('t', 'data'));
	
	
		$query->setParameters($binds);
		return $query->getResult();
	}

	/**
	 * Get the list of table fields for a given table format.
	 * If the dataset is specified, we filter on the fields of the dataset.
	 *
	 * @param String $schema
	 *        	the schema identifier
	 * @param String $format
	 *        	the format
	 * @param String $datasetID
	 *        	the dataset identifier (optional)
	 * @param
	 *        	String
	 *        	The locale
	 * @return Array[TableField]
	 */
	public function getTableFields($schema, $format, $datasetID = null, $lang) {
		$binds = array(
			'schema' => $schema,
			'format' => $format
		);
		
		// Get the fields specified by the format
		$sql = "SELECT DISTINCT table_field.*, COALESCE(t.label, data.label) as label, data.unit, unit.type, unit.subtype, COALESCE(t.definition, data.definition) as definition ";
		$sql .= " FROM table_field ";
		if ($datasetID != null) {
			$sql .= " LEFT JOIN dataset_fields on (table_field.format = dataset_fields.format AND table_field.data = dataset_fields.data) ";
		}
		$sql .= " LEFT JOIN table_format on (table_format.format = table_field.format) ";
		$sql .= " LEFT JOIN data on (table_field.data = data.data) ";
		$sql .= " LEFT JOIN unit on (data.unit = unit.unit) ";
		$sql .= " LEFT JOIN translation t ON (lang = :lang AND table_format = 'DATA' AND row_pk = data.data) ";
		$sql .= " WHERE (1=1)";
		$binds['lang'] = $lang;
		if ($datasetID != null) {
			$sql .= " AND dataset_fields.dataset_id = :dataset ";
			$binds['dataset'] = $datasetID;
		}
		$sql .= " AND table_format.schema_code = :schema";
		$sql .= " AND table_field.format = :format";
		$sql .= " ORDER BY table_field.position ";
		
		$rsm = new ResultSetMappingBuilder($this->_em);
		$rsm->addRootEntityFromClassMetadata($this->_entityName, 't');
		
		$query = $this->_em->createNativeQuery($sql, $rsm->addIndexBy('t', 'data'));
		/*
		 * //$dql = "SELECT f FROM $this->_entityName f ";
		 * $query = $this->createQueryBuilder('t', 't.data.id');
		 * $query->leftJoin('t.format', 'tf', Join::WITH, 'tf.is_primary = 1');
		 * $query->where('t.format = :format')->andWhere('tf.schema = :schema');
		 *
		 * $query->setParameters(array('schema' => $schema, 'format' => $format));
		 *
		 * if ($datasetID != null) {
		 * $query->leftJoin('DatasetField', 'df', Join::WITH, 'f.format = df.format AND f.format = df.format');
		 * $query->andWhere('df.id = :dataset');
		 * $query->setParameter('dataset', $datasetID);
		 * }
		 */
		
		$query->setParameters($binds);
		return $query->getResult();
	}

	/**
	 * Get the database field corresponding to the asked form field.
	 *
	 * @param String $schema
	 *        	the name of the schema (RAW_DATA)
	 * @param Application_Object_Metadata_FormField $formField
	 *        	the form field
	 * @param
	 *        	String
	 *        	The locale
	 * @return Application_Object_Metadata_TableField
	 */
	public function getFormToTableMapping($schema, GenericField $formField, $lang) {
		$rsm = new ResultSetMappingBuilder($this->_em);
		$rsm->addRootEntityFromClassMetadata($this->_entityName, 't');
		
		$sql = " SELECT table_field.*, COALESCE(t.label, data.label) as label, COALESCE(t.definition, data.definition) as definition, unit.unit, unit.type, unit.subtype ";
		$sql .= " FROM field_mapping ";
		$sql .= " LEFT JOIN table_field on (field_mapping.dst_format = table_field.format AND field_mapping.dst_data = table_field.data) ";
		$sql .= " LEFT JOIN dataset_fields on (dataset_fields.format = table_field.format AND dataset_fields.data = table_field.data) ";
		$sql .= " LEFT JOIN data on (table_field.data = data.data)";
		$sql .= " LEFT JOIN unit on (data.unit = unit.unit)";
		$sql .= " LEFT JOIN translation t ON (lang = ? AND table_format = 'DATA' AND row_pk = data.data) ";
		$sql .= " WHERE src_format = ? ";
		$sql .= " AND src_data = ? ";
		$sql .= " AND schema_code = ? ";
		$sql .= " AND mapping_type = 'FORM'";
		$sql .= " ORDER BY table_field.position ";
		
		$query = $this->_em->createNativeQuery($sql, $rsm);
		$query->setParameters(array(
			$lang,
			$formField->getFormat(),
			$formField->getData(),
			$schema
		));
		
		return $query->getSingleResult();
	}

	/**
	 * Detect the column getting the geographical information in a list of tables.
	 * If the dataset is specified, we filter on the fields of the dataset.
	 * We always take the GEOM column the lowest in the hierarchy of tables.
	 *
	 * @param String $schema
	 *        	the schema identifier
	 * @param Array[String] $tables
	 *        	a list of table formats
	 * @return Application_Object_Metadata_TableField
	 * @throws an exception if the tables contain no geographical information
	 */
	public function getGeometryField($schema, $tables, $lang) {
		$tableFieldArray = $this->getGeometryFields($schema, $tables, $lang);
		return $tableFieldArray[0];
	}

	/**
	 * Detect the column getting the geographical information in a list of tables.
	 * If the dataset is specified, we filter on the fields of the dataset.
	 * We always take the GEOM column the lowest in the hierarchy of tables.
	 *
	 * @param String $schema
	 *        	the schema identifier
	 * @param Array[String] $tables
	 *        	a list of table formats
	 * @param
	 *        	String
	 *        	The locale
	 * @return Application_Object_Metadata_TableField
	 * @throws an exception if the tables contain no geographical information
	 */
	public function getGeometryFields($schema, $tables, $lang) {
		$rsm = new ResultSetMappingBuilder($this->_em);
		$rsm->addRootEntityFromClassMetadata($this->_entityName, 't');
		
		// Get the fields specified by the format
		$sql = "SELECT DISTINCT table_field.*, COALESCE(t.label, data.label) as label, data.unit, unit.type, unit.subtype, COALESCE(t.definition, data.definition) as definition ";
		$sql .= " FROM table_field ";
		$sql .= " LEFT JOIN table_format on (table_field.format = table_format.format) ";
		$sql .= " LEFT JOIN data on (table_field.data = data.data) ";
		$sql .= " LEFT JOIN unit on (data.unit = unit.unit) ";
		$sql .= " LEFT JOIN translation t ON (t.lang = ? AND t.table_format = table_field.format AND t.row_pk = data.data)";
		$sql .= " WHERE table_field.format = ? ";
		$sql .= " AND table_format.schema_code = ? ";
		$sql .= " AND unit.type = 'GEOM' ";
		
		$query = $this->_em->createNativeQuery($sql, $rsm);
		
		// We do the seach table by table in the inverse order
		$tableFieldArray = array();
		foreach (array_reverse($tables) as $tableName) {
			$query->setParameters(array(
				$lang,
				$tableName,
				$schema
			));
			
			$tableField = $query->getResult();
			if ($tableField) {
				$tableFieldArray[] = $tableField[0];
			}
		}
		
		if (!empty($tableFieldArray)) {
			return $tableFieldArray;
		} else {
			// No GEOM column found
			throw new \Exception("No geographical information detected");
		}
	}
	
	/**
	 * Deletes all the fields of the table.
	 *
	 * @param
	 *        	tableFormat the name of the table f
	 *
	 * @return result of the delete query
	 */
	public function deleteAllByTableFormat($tableFormat) {
		$query = $this->_em->createQuery('DELETE FROM IgnGincoBundle:Metadata\TableField t
			WHERE t.format =:tableFormat');
		$query->setParameters(array(
			'tableFormat' => $tableFormat
		));

		return $query->getResult();
	}

	/**
	 * Deletes all non-technical fields of the table.
	 *
	 * @param
	 *        	tableFormat the name of the table
	 *
	 * @return result of the delete query
	 */
	public function deleteNonTechnicalByTableFormat($tableFormat) {
		$query = $this->_em->createQuery("DELETE FROM IgnGincoBundle:Metadata\TableField t
			WHERE t.format =:tableFormat
			AND t.data NOT IN ('PROVIDER_ID', 'USER_LOGIN', 'SUBMISSION_ID')
			AND t.data NOT LIKE :ogam_id
			AND t.data NOT IN (SELECT ta.data
			FROM IgnGincoBundle:Metadata\TableField ta
			INNER JOIN IgnGincoBundle:Metadata\ModelTables mt WITH mt.table = ta.tableFormat
			INNER JOIN IgnGincoBundle:Metadata\Model m WITH m.id = mt.model
			WHERE m.ref = true)");
		$query->setParameters(array(
			'tableFormat' => $tableFormat,
			'ogam_id' => TableFormat::PK_PREFIX . '%'
		));

		return $query->getResult();
	}

	/**
	 * Deletes the foreign key towards a parent table.
	 *
	 * @param
	 *        	format the name of the table
	 * @return result of the delete query
	 */
	public function deleteForeignKeysByTableFormat($format) {
		
		$sql = "DELETE FROM metadata.table_field f
			WHERE f.format =:format
			AND f.data LIKE :fkCondition
			AND f.data != :pkCondition";
		
		$conn = $this->getEntityManager()->getConnection() ;
		$sth = $conn->prepare($sql) ;
		$sth->execute(array(
			'format' => $format,
			'fkCondition' => TableFormat::PK_PREFIX . '%',
			'pkCondition' => TableFormat::PK_PREFIX . $format
		));
	}

	/**
	 * Get the fields listed in tables in model that are marked as reference models.
	 *
	 * @return array
	 */
	public function findReferenceFields() {
		$query = $this->_em->createQuery("SELECT dt.data
			FROM IgnGincoBundle:Metadata\TableField t
			INNER JOIN IgnGincoBundle:Metadata\Data dt WITH dt.data = t.data
			INNER JOIN IgnGincoBundle:Metadata\ModelTables mt WITH mt.table = t.format
			INNER JOIN IgnGincoBundle:Metadata\Model m WITH m.id = mt.model
			WHERE m.ref = true");
		return $query->getResult();
	}

	/**
	 * Deletes all non-technical and non-reference fields of the table.
	 *
	 * @param
	 *        	tableFormat the name of the table
	 *
	 * @return result of the delete query
	 */
	public function deleteNonTechnicalAndNonRefByTableFormat($tableFormat) {
		$qb = $this->_em->createQueryBuilder();
		$qb2 = $this->_em->createQueryBuilder();

		$query = $qb->select('t')
			->from('IgnGincoBundle:Metadata\TableField', 't')
			->where('t.tableFormat = :tableFormat')
			->andwhere("t.data NOT IN ('PROVIDER_ID', 'USER_LOGIN', 'SUBMISSION_ID')")
			->andwhere('t.data NOT LIKE :ogam_id')
			->andwhere($qb->expr()
			->notIn('t.data', $qb2->select('tf.data')
			->from('IgnGincoBundle:Metadata\TableField', 'tf')
			->join('IgnGincoBundle:Metadata\ModelTables', 'mt', \Doctrine\ORM\Query\Expr\Join::WITH, $qb2->expr()
			->eq(' mt.table', 'tf.tableFormat'))
			->join('IgnGincoBundle:Metadata\Model', 'm', \Doctrine\ORM\Query\Expr\Join::WITH, $qb2->expr()
			->eq(' m.id', 'mt.model'))
			->where('m.ref = true')
			->getDQL()))
			->setParameters(array(
			'tableFormat' => $tableFormat,
			'ogam_id' => TableFormat::PK_PREFIX . '%'
		))
			->getQuery();
		$results = $query->execute();

		// Delete the results
		foreach ($results as $result) {
			$this->_em->remove($result);
		}
		// Don't forget to flush in the controller
		return true;
	}
}
